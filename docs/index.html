<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kids Numbers Grid Animation</title>
    <style>
        :root {
            --color-primary: #3182ce;
            --color-primary-hover: #2c5aa0;
            --color-success: #22c55e;
            --color-text: #1f2937;
            --color-bg: #f9fafb;
            --color-surface: #ffffff;
            --color-border: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            height: calc(100% - 120px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.08);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: var(--color-text);
            min-width: 120px;
        }

        input[type="number"] {
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 16px;
            width: 80px;
            color: var(--color-text);
            background: var(--color-surface);
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }

        .btn {
            padding: 10px 20px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 150ms ease;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .info {
            margin-left: auto;
            color: #6b7280;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-wrap: wrap;
            }

            label {
                min-width: auto;
            }

            .info {
                margin-left: 0;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label for="numberInput">Count:</label>
            <input type="number" id="numberInput" value="20" min="1">
        </div>

        <div class="control-group">
            <label for="orderSelect">Group order:</label>
            <select id="orderSelect">
                <option value="row">Row-major (default)</option>
                <option value="column">Column-major</option>
                <option value="spiral">Spiral</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div class="control-group">
            <label for="colsInput">Columns (0 = auto):</label>
            <input type="number" id="colsInput" value="0" min="0" max="100">
        </div>

        <div class="control-group">
            <label for="gridFontSize">Grid font size:</label>
            <input type="number" id="gridFontSize" value="200" min="8" max="256">
        </div>

        <div class="control-group">
            <label for="ballFontSize">Ball font size:</label>
            <input type="number" id="ballFontSize" value="180" min="8" max="1024">
        </div>

        <div class="control-group">
            <label for="autoRotate">Auto-rotate:</label>
            <input type="checkbox" id="autoRotate" title="Toggle auto rotation of the grid">
        </div>

        <div class="control-group">
            <label for="ballsOnly">Balls only (fast):</label>
            <input type="checkbox" id="ballsOnly" title="Hide grid and numbers to improve performance when creating many balls" checked>
        </div>

        <button class="btn" onclick="updateNumbers()">Update Grid</button>
        <div class="info">ðŸ’¡ Change the count and click Update to animate the removal/addition of balls</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf9fafb);

        const canvas = document.getElementById('canvas');
        const camera = new THREE.PerspectiveCamera(
            75,
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);

        // Grid container
        const gridGroup = new THREE.Group();
        scene.add(gridGroup);
    // Grid lines and labels container
    const gridLinesGroup = new THREE.Group();
    scene.add(gridLinesGroup);

        // Ball configuration
        const ballRadius = 0.8;
        const spacing = 2.5;
        const colors = [
            0xff6b6b, // Red
            0x4ecdc4, // Teal
            0xffe66d, // Yellow
            0x95e1d3, // Mint
            0xf38181, // Pink
            0xaa96da, // Purple
            0xfcbad3, // Light pink
            0xa8edea, // Cyan
            0xfed766, // Gold
            0xff006e  // Magenta
        ];

        let balls = [];
        let animatingBalls = new Set();
    // Current grouping order (row, column, spiral, random)
    let currentOrder = 'row';
    // Column override (0 = auto compute)
    let currentCols = 0;
    // Auto-rotate flag
    let currentAutoRotate = false;
    // Font sizes
    let currentGridFontSize = 64; // used for grid labels
    let currentBallFontSize = 280; // used for numbers painted on balls
    // Lightweight mode flags (fast mode defaults ON)
    let currentShowGrid = false;
    let currentShowNumbers = false;

        // Returns an ordered list of positions for `count` items according to `order`.
        // Optional `cols` argument overrides the number of columns (0 = auto).
        function getGridLayout(count, order = 'row', cols = 0) {
            const gridCols = cols > 0 ? cols : Math.ceil(Math.sqrt(count));
            const gridRows = Math.ceil(count / gridCols);
            const width = (gridCols - 1) * spacing;
            const height = (gridRows - 1) * spacing;

            // Create base positions for the full grid (gridRows x gridCols)
            const total = gridRows * gridCols;
            const basePositions = [];
            for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                    const x = c * spacing - width / 2;
                    const y = r * spacing - height / 2;
                    basePositions.push({ x, y, i: r * gridCols + c });
                }
            }

            // Build an indices array in the requested order, then take the first `count` entries
            let indices = [];
            if (order === 'row') {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            } else if (order === 'column') {
                for (let c = 0; c < gridCols; c++) {
                    for (let r = 0; r < gridRows; r++) {
                        indices.push(r * gridCols + c);
                    }
                }
                indices = indices.slice(0, count);
            } else if (order === 'spiral') {
                indices = getSpiralIndices(gridRows, gridCols).slice(0, count);
            } else if (order === 'random') {
                indices = Array.from({ length: total }, (_, i) => i);
                shuffleArray(indices);
                indices = indices.slice(0, count);
            } else {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            }

            return indices.map(idx => ({ x: basePositions[idx].x, y: basePositions[idx].y, i: idx }));
        }

        // Spiral ordering helper: returns array of indices for a gridSize x gridSize grid
        // Spiral ordering helper for rectangular grid: rows x cols
        function getSpiralIndices(rows, cols) {
            const result = [];
            let top = 0, bottom = rows - 1, left = 0, right = cols - 1;
            while (top <= bottom && left <= right) {
                for (let c = left; c <= right; c++) result.push(top * cols + c);
                top++;
                for (let r = top; r <= bottom; r++) result.push(r * cols + right);
                right--;
                if (top <= bottom) {
                    for (let c = right; c >= left; c--) result.push(bottom * cols + c);
                    bottom--;
                }
                if (left <= right) {
                    for (let r = bottom; r >= top; r--) result.push(r * cols + left);
                    left++;
                }
            }
            return result;
        }

        // Fisher-Yates shuffle
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function createBall(position, index) {
            // create an empty mesh and initialize rendering based on fast-mode
            const mesh = new THREE.Mesh();
            mesh.position.set(position.x, position.y, 0);
            mesh.userData = { number: index + 1, _colorIndex: index % colors.length };

            // Set geometry/material according to fast-mode state
            setBallRenderingMode(mesh, index, !currentShowNumbers);

            gridGroup.add(mesh);
            return mesh;
        }

        // Switch a ball between fast (2D, no textures) and normal (3D sphere + material) rendering
        function setBallRenderingMode(ball, index, fast) {
            // Dispose previous geometry/material if present
            if (ball.geometry) {
                try { ball.geometry.dispose(); } catch (e) {}
            }
            if (ball.material) {
                try { ball.material.dispose(); } catch (e) {}
            }
            // Also remove any label children if switching to fast
            if (fast) {
                // 2D: use a CircleGeometry with a simple MeshBasicMaterial (no lights, no textures)
                const geo = new THREE.CircleGeometry(ballRadius, 16);
                const color = colors[index % colors.length];
                const mat = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
                ball.geometry = geo;
                ball.material = mat;
                // Remove labels if present
                removeBallLabel(ball);
                // Ensure orientation faces camera (Circle in XY plane facing +Z is fine)
                ball.rotation.set(0, 0, 0);
            } else {
                // 3D: sphere with standard material
                const geo = new THREE.SphereGeometry(ballRadius, 32, 32);
                const color = colors[index % colors.length];
                const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.4, metalness: 0.3 });
                ball.geometry = geo;
                ball.material = mat;
                // Add label if numbers are enabled
                if (currentShowNumbers) {
                    createBallLabel(ball);
                }
            }
        }

        // Create a label mesh for an existing ball (uses ball.userData.number)
        function createBallLabel(ball) {
            // avoid creating duplicate labels
            const existing = ball.children.find(c => c.material && c.material.map);
            if (existing) return existing;

            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = '#000000';
            ctx.font = `bold ${currentBallFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(ball.userData.number, size / 2, size / 2);

            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;

            const labelGeometry = new THREE.PlaneGeometry(2.2, 2.2);
            const labelMaterial = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
            labelMesh.position.z = ballRadius + 0.1;
            ball.add(labelMesh);
            return labelMesh;
        }

        function removeBallLabel(ball) {
            const labelMesh = ball.children.find(c => c.material && c.material.map);
            if (!labelMesh) return;
            if (labelMesh.material.map) labelMesh.material.map.dispose();
            if (labelMesh.material) labelMesh.material.dispose();
            if (labelMesh.geometry) labelMesh.geometry.dispose();
            ball.remove(labelMesh);
        }

        // Create or update grid lines and numeric labels for rows/columns
        function updateGridVisuals(count, colsOverride = 0) {
            // Clear previous visuals
            gridLinesGroup.children.slice().forEach(child => {
                gridLinesGroup.remove(child);
                // dispose geometries and materials if any
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
                // dispose textures on children
                if (child.children) {
                    child.children.forEach(c => {
                        if (c.material && c.material.map) c.material.map.dispose();
                        if (c.material) c.material.dispose();
                        if (c.geometry) c.geometry.dispose();
                    });
                }
            });

            // If grid display is disabled (lightweight mode), don't recreate visuals
            if (!currentShowGrid) return;

            const gridCols = colsOverride > 0 ? colsOverride : Math.ceil(Math.sqrt(count));
            const gridRows = Math.ceil(count / gridCols);
            const width = (gridCols - 1) * spacing;
            const height = (gridRows - 1) * spacing;

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xd1d5db });

            const vertices = [];
            // vertical lines
            for (let c = 0; c < gridCols; c++) {
                const x = c * spacing - width / 2;
                vertices.push(x, -height / 2, 0, x, height / 2, 0);
            }
            // horizontal lines
            for (let r = 0; r < gridRows; r++) {
                const y = r * spacing - height / 2;
                vertices.push(-width / 2, y, 0, width / 2, y, 0);
            }

            const lineGeom = new THREE.BufferGeometry();
            lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const lines = new THREE.LineSegments(lineGeom, lineMaterial);
            gridLinesGroup.add(lines);

            // Labels for columns (top)
            for (let c = 0; c < gridCols; c++) {
                const x = c * spacing - width / 2;
                    const label = createTextLabel((c + 1).toString(), currentGridFontSize, '#374151');
                label.position.set(x, height / 2 + spacing * 0.6, 0.1);
                gridLinesGroup.add(label);
            }

            // Labels for rows (left)
            for (let r = 0; r < gridRows; r++) {
                const y = r * spacing - height / 2;
                const label = createTextLabel((r + 1).toString(), currentGridFontSize, '#374151');
                // rotate so text faces the camera similarly; using PlaneGeometry so no rotation needed
                label.position.set(-width / 2 - spacing * 0.6, y, 0.1);
                gridLinesGroup.add(label);
            }
        }

        // helper: create a small 2D canvas text as a THREE.Mesh (Plane) for labels
        function createTextLabel(text, fontSize = 64, color = '#000') {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = color;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2);

            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;

            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            const geom = new THREE.PlaneGeometry((fontSize / 64) * 1.2, (fontSize / 64) * 1.2);
            const mesh = new THREE.Mesh(geom, mat);
            return mesh;
        }

        function initializeBalls(count) {
            // Clear existing balls
            balls.forEach(ball => {
                gridGroup.remove(ball);
                disposeBall(ball);
            });
            balls = [];

            // Update grid visuals (lines & labels)
            updateGridVisuals(count, currentCols);

            // Create new balls
            const positions = getGridLayout(count, currentOrder, currentCols);
            positions.forEach((pos, idx) => {
                const ball = createBall(pos, idx);
                balls.push(ball);            // Initial scale animation
            ball.scale.set(0, 0, 0);
            animateBallIn(ball, 0.2 + idx * 0.01);
            });
        }

        // Update label texture on a single ball to match currentBallFontSize
        function updateBallLabel(ball, newFontSize) {
            // find existing label mesh
            const labelMesh = ball.children.find(c => c.material && c.material.map);
            // If no label exists but numbers are enabled, create one
            if (!labelMesh) {
                if (currentShowNumbers) {
                    createBallLabel(ball);
                }
                return;
            }

            // If numbers are disabled, remove the label
            if (!currentShowNumbers) {
                removeBallLabel(ball);
                return;
            }

            // dispose old texture and replace with new sized texture
            const oldMap = labelMesh.material.map;
            if (oldMap) oldMap.dispose();

            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = '#000000';
            ctx.font = `bold ${newFontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(ball.userData.number, size / 2, size / 2);

            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            labelMesh.material.map = tex;
            labelMesh.material.needsUpdate = true;
        }

        // Update labels for all existing balls
        function updateAllBallLabels(newFontSize) {
            if (currentShowNumbers) {
                // ensure each ball has a label and update it
                balls.forEach(b => updateBallLabel(b, newFontSize));
            } else {
                // remove any existing labels to free textures
                balls.forEach(b => removeBallLabel(b));
            }
        }

        function animateBallIn(ball, delay) {
            animatingBalls.add(ball);
            const startTime = performance.now();
            const duration = 500;

            function animate(currentTime) {
                const elapsed = currentTime - startTime - delay * 1000;
                const progress = Math.min(Math.max(elapsed / duration, 0), 1);
                const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                ball.scale.set(easeProgress, easeProgress, easeProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    ball.scale.set(1, 1, 1);
                    animatingBalls.delete(ball);
                }
            }
            requestAnimationFrame(animate);
        }

        function animateBallOut(ball, callback) {
            animatingBalls.add(ball);
            const startTime = performance.now();
            const duration = 400;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                ball.scale.set(1 - progress, 1 - progress, 1 - progress);
                ball.rotation.z += 0.05;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gridGroup.remove(ball);
                    ball.geometry.dispose();
                    ball.material.dispose();
                    if (ball.children[0]) {
                        ball.children[0].material.dispose();
                    }            animatingBalls.delete(ball);
            if (callback) callback();
                }
            }
            requestAnimationFrame(animate);
        }

        function disposeBall(ball) {
            ball.geometry.dispose();
            ball.material.dispose();
            // Dispose children materials
            ball.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            });
        }

        function updateNumbers() {
            const input = document.getElementById('numberInput');
            const raw = parseInt(input.value);
            const newCount = Math.max(1, Number.isInteger(raw) ? raw : 20);
            input.value = newCount;

            // read order selection
            const order = document.getElementById('orderSelect') ? document.getElementById('orderSelect').value : 'row';
            currentOrder = order;

            // Update grid visuals for the new count/order
            const colsInput = document.getElementById('colsInput');
            const colsVal = colsInput ? parseInt(colsInput.value) || 0 : 0;
            currentCols = colsVal;
            updateGridVisuals(newCount, currentCols);

            const currentCount = balls.length;

            if (newCount > currentCount) {
                // Add new balls
                const positions = getGridLayout(newCount, order, currentCols);
                for (let i = currentCount; i < newCount; i++) {
                    const ball = createBall(positions[i], i);
                    balls.push(ball);
                    animateBallIn(ball, 0.1 + (i - currentCount) * 0.02);
                }
            } else if (newCount < currentCount) {
                // Remove balls with animation
                const ballsToRemove = balls.splice(newCount);
                ballsToRemove.forEach((ball, idx) => {
                    animateBallOut(ball);
                });
            } else {
                // Reposition existing balls
                const newPositions = getGridLayout(newCount, order, currentCols);
                balls.forEach((ball, idx) => {
                    const targetPos = newPositions[idx];
                    animateBallPosition(ball, targetPos);
                });
            }
        }

        function animateBallPosition(ball, targetPos) {
            const startPos = { x: ball.position.x, y: ball.position.y };
            const startTime = performance.now();
            const duration = 500;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                ball.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                ball.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Rotation animation
        function animate() {
            requestAnimationFrame(animate);
            // rotate only if enabled
            if (currentAutoRotate) {
                gridGroup.rotation.z += 0.0005;
            }

            renderer.render(scene, camera);
        }

        // Initialize with default count
        initializeBalls(20);
        animate();

        // Allow Enter key to update
        document.getElementById('numberInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') updateNumbers();
        });

        // Allow mouse wheel to change the Count input when hovering over it
        const numberInputEl = document.getElementById('numberInput');
        if (numberInputEl) {
            numberInputEl.addEventListener('wheel', (e) => {
                // only handle when pointer is over the input
                e.preventDefault();
                const step = e.shiftKey ? 10 : 1; // hold Shift to change faster
                const dir = e.deltaY < 0 ? 1 : -1; // wheel up -> increase
                const min = parseInt(numberInputEl.getAttribute('min')) || 1;
                const maxAttr = numberInputEl.getAttribute('max');
                const max = (maxAttr !== null) ? parseInt(maxAttr) : Infinity;
                let val = parseInt(numberInputEl.value) || 0;
                val = val + dir * step;
                val = Math.max(min, Math.min(max, val));
                if (val !== parseInt(numberInputEl.value)) {
                    numberInputEl.value = val;
                    updateNumbers();
                }
            }, { passive: false });
        }

        // Helper to attach wheel increment to any number input
        function attachWheelToNumberInput(selector, onChangeCallback, opts = {}) {
            const el = document.getElementById(selector);
            if (!el) return;
            el.addEventListener('wheel', (e) => {
                e.preventDefault();
                const baseStep = opts.step || 1;
                const bigStep = opts.bigStep || (baseStep * 10);
                const step = e.shiftKey ? bigStep : baseStep;
                const dir = e.deltaY < 0 ? 1 : -1;
                const min = parseInt(el.getAttribute('min')) || -Infinity;
                const max = parseInt(el.getAttribute('max')) || Infinity;
                let val = parseInt(el.value) || 0;
                val = val + dir * step;
                val = Math.max(min, Math.min(max, val));
                if (val !== parseInt(el.value)) {
                    el.value = val;
                    try { onChangeCallback(el, val); } catch (err) { /* swallow */ }
                }
            }, { passive: false });
        }

        // Attach wheel handlers to other numeric inputs
        attachWheelToNumberInput('colsInput', () => updateNumbers(), { step: 1, bigStep: 5 });
        attachWheelToNumberInput('gridFontSize', () => {
            const el = document.getElementById('gridFontSize');
            const v = parseInt(el.value) || 64;
            currentGridFontSize = v;
            updateGridVisuals(balls.length, currentCols);
        }, { step: 1, bigStep: 8 });
        attachWheelToNumberInput('ballFontSize', () => {
            const el = document.getElementById('ballFontSize');
            const v = parseInt(el.value) || 280;
            currentBallFontSize = v;
            updateAllBallLabels(currentBallFontSize);
        }, { step: 2, bigStep: 20 });

        // Reposition when grouping order or columns change; wire auto-rotate toggle and wheel zoom
        const orderSelect = document.getElementById('orderSelect');
        if (orderSelect) {
            orderSelect.addEventListener('change', () => {
                updateNumbers();
            });
        }

        const colsInput = document.getElementById('colsInput');
        if (colsInput) {
            colsInput.addEventListener('change', () => {
                updateNumbers();
            });
        }

        const gridFontInput = document.getElementById('gridFontSize');
        if (gridFontInput) {
            gridFontInput.addEventListener('change', (e) => {
                const v = parseInt(e.target.value) || 64;
                currentGridFontSize = v;
                // refresh grid visuals only
                updateGridVisuals(balls.length, currentCols);
            });
        }

        const ballFontInput = document.getElementById('ballFontSize');
        if (ballFontInput) {
            ballFontInput.addEventListener('change', (e) => {
                const v = parseInt(e.target.value) || 280;
                currentBallFontSize = v;
                // update existing balls' labels
                updateAllBallLabels(currentBallFontSize);
            });
        }

        const autoRotateCheckbox = document.getElementById('autoRotate');
        if (autoRotateCheckbox) {
            autoRotateCheckbox.addEventListener('change', (e) => {
                currentAutoRotate = !!e.target.checked;
            });
        }

        // Apply the 'balls only' lightweight mode: hide grid and hide numbers
        function applyBallsOnlyMode(enabled) {
            if (enabled) {
                currentShowGrid = false;
                currentShowNumbers = false;
            } else {
                currentShowGrid = true;
                currentShowNumbers = true;
            }

            // Update visuals accordingly
            updateGridVisuals(balls.length, currentCols);
            updateAllBallLabels(currentBallFontSize);

            // Update existing balls to match the rendering mode (2D fast vs 3D normal)
            balls.forEach((ball, idx) => {
                setBallRenderingMode(ball, idx, !currentShowNumbers);
            });
        }

        const ballsOnlyCheckbox = document.getElementById('ballsOnly');
        if (ballsOnlyCheckbox) {
            ballsOnlyCheckbox.addEventListener('change', (e) => {
                applyBallsOnlyMode(!!e.target.checked);
            });
        }

        // Mouse wheel zoom (adjust camera z)
        // Ignore wheel events that originate from the controls area (so scrolling inputs doesn't zoom)
        window.addEventListener('wheel', (ev) => {
            // If the wheel event originated from inside the controls UI (inputs), don't zoom
            if (ev.target && ev.target.closest && ev.target.closest('.controls')) return;

            // Prevent page scroll when interacting with canvas
            ev.preventDefault();
            const delta = ev.deltaY;
            camera.position.z += delta * 0.02; // adjust sensitivity
            camera.position.z = Math.max(8, Math.min(200, camera.position.z));
            camera.updateProjectionMatrix();
        }, { passive: false });
    </script>
</body>
</html>
