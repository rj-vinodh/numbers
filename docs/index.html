<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kids Numbers Grid Animation</title>
    <style>
        :root {
            --color-primary: #3182ce;
            --color-primary-hover: #2c5aa0;
            --color-success: #22c55e;
            --color-text: #1f2937;
            --color-bg: #f9fafb;
            --color-surface: #ffffff;
            --color-border: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            height: calc(100% - 120px);
        }

        /* container used by the p5 sketch (replaces the canvas element) */
        #sketchContainer {
            display: block;
            width: 100%;
            height: calc(100% - 120px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.08);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: var(--color-text);
            min-width: 120px;
        }

        input[type="number"] {
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 16px;
            width: 80px;
            color: var(--color-text);
            background: var(--color-surface);
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }

        .btn {
            padding: 10px 20px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 150ms ease;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .info {
            margin-left: auto;
            color: #6b7280;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-wrap: wrap;
            }

            label {
                min-width: auto;
            }

            .info {
                margin-left: 0;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="sketchContainer"></div>
    
    <div class="controls">
        <div class="control-group">
            <label for="numberInput">Count:</label>
            <input type="number" id="numberInput" value="20" min="1">
        </div>

        <div class="control-group">
            <label for="orderSelect">Group order:</label>
            <select id="orderSelect">
                <option value="row">Row-major (default)</option>
                <option value="column">Column-major</option>
                <option value="spiral">Spiral</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div class="control-group">
            <label for="colsInput">Columns (0 = auto):</label>
            <input type="number" id="colsInput" value="0" min="0" max="100">
        </div>

        <div class="control-group">
            <label for="gridFontSize">Grid font size:</label>
            <input type="number" id="gridFontSize" value="200" min="8" max="256">
        </div>

        <div class="control-group">
            <label for="ballFontSize">Ball font size:</label>
            <input type="number" id="ballFontSize" value="180" min="8" max="1024">
        </div>

        <div class="control-group">
            <label for="autoRotate">Auto-rotate:</label>
            <input type="checkbox" id="autoRotate" title="Toggle auto rotation of the grid">
        </div>

        <div class="control-group">
            <label for="ballsOnly">Balls only (fast):</label>
            <input type="checkbox" id="ballsOnly" title="Hide grid and numbers to improve performance when creating many balls" checked>
        </div>

        <button class="btn" onclick="updateNumbers()">Update Grid</button>
        <div class="info">ðŸ’¡ Change the count and click Update to animate the removal/addition of balls</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.min.js"></script>
    <script>
        // ----- p5.js 2D implementation replacing Three.js -----
        const spacing = 70; // pixel spacing between items
        const ballRadius = 28; // visual radius in pixels for discs
        const colors = [
            '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8edea', '#fed766', '#ff006e'
        ];

        let balls = [];
        let animatingBalls = new Set();
        let currentOrder = 'row';
        let currentCols = 0;
        let currentAutoRotate = false; // not used in 2D but kept for compatibility
        let currentGridFontSize = 24; // px
        let currentBallFontSize = 18; // px
        let currentShowGrid = false; // fast mode default
        let currentShowNumbers = false; // fast mode default

        // Grid layout state for drawing
        let gridCols = 0, gridRows = 0, gridWidth = 0, gridHeight = 0;

        // viewport / p5 canvas
        let sketchWidth = 800, sketchHeight = 600;
        let globalScale = 1; // used for wheel zoom

        function getGridLayout(count, order = 'row', cols = 0) {
            const gridC = cols > 0 ? cols : Math.ceil(Math.sqrt(count));
            const gridR = Math.ceil(count / gridC);
            gridCols = gridC; gridRows = gridR;
            gridWidth = (gridC - 1) * spacing;
            gridHeight = (gridR - 1) * spacing;

            const total = gridR * gridC;
            const basePositions = [];
            for (let r = 0; r < gridR; r++) {
                for (let c = 0; c < gridC; c++) {
                    const x = c * spacing - gridWidth / 2;
                    const y = r * spacing - gridHeight / 2;
                    basePositions.push({ x, y, i: r * gridC + c });
                }
            }

            let indices = [];
            if (order === 'row') {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            } else if (order === 'column') {
                for (let c = 0; c < gridC; c++) for (let r = 0; r < gridR; r++) indices.push(r * gridC + c);
                indices = indices.slice(0, count);
            } else if (order === 'spiral') {
                indices = getSpiralIndices(gridR, gridC).slice(0, count);
            } else if (order === 'random') {
                indices = Array.from({ length: total }, (_, i) => i);
                shuffleArray(indices);
                indices = indices.slice(0, count);
            } else {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            }

            return indices.map(idx => ({ x: basePositions[idx].x, y: basePositions[idx].y, i: idx }));
        }

        function getSpiralIndices(rows, cols) {
            const result = [];
            let top = 0, bottom = rows - 1, left = 0, right = cols - 1;
            while (top <= bottom && left <= right) {
                for (let c = left; c <= right; c++) result.push(top * cols + c);
                top++;
                for (let r = top; r <= bottom; r++) result.push(r * cols + right);
                right--;
                if (top <= bottom) { for (let c = right; c >= left; c--) result.push(bottom * cols + c); bottom--; }
                if (left <= right) { for (let r = bottom; r >= top; r--) result.push(r * cols + left); left++; }
            }
            return result;
        }

        function shuffleArray(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }

        function initializeBalls(count) {
            balls = [];
            const positions = getGridLayout(count, currentOrder, currentCols);
            positions.forEach((pos, idx) => {
                const b = {
                    x: pos.x, y: pos.y,
                    drawX: pos.x, drawY: pos.y,
                    number: idx + 1,
                    color: colors[idx % colors.length],
                    scale: 0, targetScale: 1,
                    removing: false
                };
                balls.push(b);
            });
        }

        function updateNumbers() {
            const input = document.getElementById('numberInput');
            const raw = parseInt(input.value);
            const newCount = Math.max(1, Number.isInteger(raw) ? raw : 20);
            input.value = newCount;

            const order = document.getElementById('orderSelect') ? document.getElementById('orderSelect').value : 'row';
            currentOrder = order;

            const colsInput = document.getElementById('colsInput');
            const colsVal = colsInput ? parseInt(colsInput.value) || 0 : 0;
            currentCols = colsVal;

            const currentCount = balls.length;
            if (newCount > currentCount) {
                const positions = getGridLayout(newCount, order, currentCols);
                for (let i = currentCount; i < newCount; i++) {
                    const pos = positions[i];
                    const b = { x: pos.x, y: pos.y, drawX: pos.x, drawY: pos.y, number: i + 1, color: colors[i % colors.length], scale: 0, targetScale: 1, removing:false };
                    balls.push(b);
                }
            } else if (newCount < currentCount) {
                // mark extras for removal (quick shrink)
                const toRemove = balls.splice(newCount);
                // no heavy disposal needed in p5; they will disappear next frame
            } else {
                // reposition existing
                const newPositions = getGridLayout(newCount, order, currentCols);
                balls.forEach((b, idx) => { if (newPositions[idx]) { b.x = newPositions[idx].x; b.y = newPositions[idx].y; } });
            }
        }

        // p5 sketch
        let sketchCanvas;
        const sketch = (p) => {
            p.setup = () => {
                const container = document.getElementById('sketchContainer');
                sketchWidth = container.clientWidth;
                sketchHeight = container.clientHeight;
                sketchCanvas = p.createCanvas(sketchWidth, sketchHeight);
                sketchCanvas.parent('sketchContainer');
                p.pixelDensity(window.devicePixelRatio || 1);
                p.textAlign(p.CENTER, p.CENTER);
                p.ellipseMode(p.CENTER);
                initializeBalls(parseInt(document.getElementById('numberInput').value || 20));
            };

            p.windowResized = () => {
                const container = document.getElementById('sketchContainer');
                sketchWidth = container.clientWidth;
                sketchHeight = container.clientHeight;
                p.resizeCanvas(sketchWidth, sketchHeight);
            };

            p.draw = () => {
                p.background(249,250,251);
                p.push();
                // translate to center and scale for zoom
                p.translate(sketchWidth/2, sketchHeight/2);
                p.scale(globalScale);

                // draw grid if enabled
                if (currentShowGrid) {
                    p.stroke('#d1d5db');
                    p.strokeWeight(1);
                    // vertical lines
                    for (let c = 0; c < gridCols; c++) {
                        const x = c * spacing - gridWidth/2;
                        p.line(x, -gridHeight/2, x, gridHeight/2);
                    }
                    // horizontal lines
                    for (let r = 0; r < gridRows; r++) {
                        const y = r * spacing - gridHeight/2;
                        p.line(-gridWidth/2, y, gridWidth/2, y);
                    }

                    // labels
                    p.fill('#374151');
                    p.noStroke();
                    p.textSize(currentGridFontSize);
                    // columns
                    for (let c = 0; c < gridCols; c++) {
                        const x = c * spacing - gridWidth/2;
                        p.text((c+1).toString(), x, -gridHeight/2 - spacing*0.6);
                    }
                    // rows
                    for (let r = 0; r < gridRows; r++) {
                        const y = r * spacing - gridHeight/2;
                        p.text((r+1).toString(), -gridWidth/2 - spacing*0.6, y);
                    }
                }

                // draw balls
                balls.forEach((b, idx) => {
                    // ease position
                    b.drawX += (b.x - b.drawX) * 0.15;
                    b.drawY += (b.y - b.drawY) * 0.15;
                    // scale animation
                    b.scale += (b.targetScale - b.scale) * 0.18;

                    p.push();
                    p.translate(b.drawX, b.drawY);
                    p.noStroke();
                    p.fill(b.color);
                    p.ellipse(0, 0, ballRadius*2*b.scale, ballRadius*2*b.scale);
                    if (currentShowNumbers) {
                        p.fill(0);
                        p.textSize(currentBallFontSize);
                        p.text(b.number.toString(), 0, 0);
                    }
                    p.pop();
                });

                p.pop();
            };
        };
        new p5(sketch);

        // wire existing UI controls
        document.getElementById('numberInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') updateNumbers(); });

        function attachWheelToNumberInput(selector, onChangeCallback, opts = {}) {
            const el = document.getElementById(selector);
            if (!el) return;
            el.addEventListener('wheel', (e) => {
                e.preventDefault();
                const baseStep = opts.step || 1;
                const bigStep = opts.bigStep || (baseStep * 10);
                const step = e.shiftKey ? bigStep : baseStep;
                const dir = e.deltaY < 0 ? 1 : -1;
                const min = parseInt(el.getAttribute('min')) || -Infinity;
                const max = parseInt(el.getAttribute('max')) || Infinity;
                let val = parseInt(el.value) || 0;
                val = val + dir * step;
                val = Math.max(min, Math.min(max, val));
                if (val !== parseInt(el.value)) {
                    el.value = val;
                    try { onChangeCallback(el, val); } catch (err) { /* swallow */ }
                }
            }, { passive: false });
        }

        attachWheelToNumberInput('colsInput', () => updateNumbers(), { step: 1, bigStep: 5 });
        attachWheelToNumberInput('gridFontSize', () => {
            const el = document.getElementById('gridFontSize');
            const v = parseInt(el.value) || 24;
            currentGridFontSize = v;
        }, { step: 1, bigStep: 8 });
        attachWheelToNumberInput('ballFontSize', () => {
            const el = document.getElementById('ballFontSize');
            const v = parseInt(el.value) || 18;
            currentBallFontSize = v;
        }, { step: 1, bigStep: 8 });

        // wire other controls
        const orderSelect = document.getElementById('orderSelect'); if (orderSelect) orderSelect.addEventListener('change', () => updateNumbers());
        const colsInput = document.getElementById('colsInput'); if (colsInput) colsInput.addEventListener('change', () => updateNumbers());
        const gridFontInput = document.getElementById('gridFontSize'); if (gridFontInput) gridFontInput.addEventListener('change', (e) => { currentGridFontSize = parseInt(e.target.value) || 24; });
        const ballFontInput = document.getElementById('ballFontSize'); if (ballFontInput) ballFontInput.addEventListener('change', (e) => { currentBallFontSize = parseInt(e.target.value) || 18; });
        const autoRotateCheckbox = document.getElementById('autoRotate'); if (autoRotateCheckbox) autoRotateCheckbox.addEventListener('change', (e) => { currentAutoRotate = !!e.target.checked; });

        function applyBallsOnlyMode(enabled) {
            if (enabled) { currentShowGrid = false; currentShowNumbers = false; }
            else { currentShowGrid = true; currentShowNumbers = true; }
        }
        const ballsOnlyCheckbox = document.getElementById('ballsOnly'); if (ballsOnlyCheckbox) ballsOnlyCheckbox.addEventListener('change', (e) => applyBallsOnlyMode(!!e.target.checked));

        // mouse wheel zoom for canvas (adjust globalScale), ignore events from controls
        window.addEventListener('wheel', (ev) => {
            if (ev.target && ev.target.closest && ev.target.closest('.controls')) return;
            ev.preventDefault();
            const delta = ev.deltaY;
            globalScale += delta * -0.0015; // invert so wheel up zooms in
            globalScale = Math.max(0.25, Math.min(4, globalScale));
        }, { passive: false });

        // initialize defaults
        (function initDefaults(){
            // set numeric defaults mapping from previous HTML defaults
            currentGridFontSize = parseInt(document.getElementById('gridFontSize').value) || 24;
            currentBallFontSize = parseInt(document.getElementById('ballFontSize').value) || 18;
            const ballsOnly = document.getElementById('ballsOnly'); if (ballsOnly) applyBallsOnlyMode(!!ballsOnly.checked);
        })();
    </script>
</body>
</html>
