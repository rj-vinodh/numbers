<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kids Numbers Grid Animation</title>
    <style>
        :root {
            --color-primary: #3182ce;
            --color-primary-hover: #2c5aa0;
            --color-success: #22c55e;
            --color-text: #1f2937;
            --color-bg: #f9fafb;
            --color-surface: #ffffff;
            --color-border: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            height: calc(100% - 120px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.08);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: var(--color-text);
            min-width: 120px;
        }

        input[type="number"] {
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 16px;
            width: 80px;
            color: var(--color-text);
            background: var(--color-surface);
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }

        .btn {
            padding: 10px 20px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 150ms ease;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .info {
            margin-left: auto;
            color: #6b7280;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-wrap: wrap;
            }

            label {
                min-width: auto;
            }

            .info {
                margin-left: 0;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label for="numberInput">Count:</label>
            <input type="number" id="numberInput" value="20" min="1" max="100">
        </div>

        <div class="control-group">
            <label for="orderSelect">Group order:</label>
            <select id="orderSelect">
                <option value="row">Row-major (default)</option>
                <option value="column">Column-major</option>
                <option value="spiral">Spiral</option>
                <option value="random">Random</option>
            </select>
        </div>

        <div class="control-group">
            <label for="colsInput">Columns (0 = auto):</label>
            <input type="number" id="colsInput" value="0" min="0" max="100">
        </div>

        <div class="control-group">
            <label for="autoRotate">Auto-rotate:</label>
            <input type="checkbox" id="autoRotate" title="Toggle auto rotation of the grid">
        </div>

        <button class="btn" onclick="updateNumbers()">Update Grid</button>
        <div class="info">ðŸ’¡ Change the count and click Update to animate the removal/addition of balls</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf9fafb);

        const canvas = document.getElementById('canvas');
        const camera = new THREE.PerspectiveCamera(
            75,
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);

        // Grid container
        const gridGroup = new THREE.Group();
        scene.add(gridGroup);
    // Grid lines and labels container
    const gridLinesGroup = new THREE.Group();
    scene.add(gridLinesGroup);

        // Ball configuration
        const ballRadius = 0.8;
        const spacing = 2.5;
        const colors = [
            0xff6b6b, // Red
            0x4ecdc4, // Teal
            0xffe66d, // Yellow
            0x95e1d3, // Mint
            0xf38181, // Pink
            0xaa96da, // Purple
            0xfcbad3, // Light pink
            0xa8edea, // Cyan
            0xfed766, // Gold
            0xff006e  // Magenta
        ];

        let balls = [];
        let animatingBalls = new Set();
    // Current grouping order (row, column, spiral, random)
    let currentOrder = 'row';
    // Column override (0 = auto compute)
    let currentCols = 0;
    // Auto-rotate flag
    let currentAutoRotate = false;

        // Returns an ordered list of positions for `count` items according to `order`.
        // Optional `cols` argument overrides the number of columns (0 = auto).
        function getGridLayout(count, order = 'row', cols = 0) {
            const gridCols = cols > 0 ? cols : Math.ceil(Math.sqrt(count));
            const gridRows = Math.ceil(count / gridCols);
            const width = (gridCols - 1) * spacing;
            const height = (gridRows - 1) * spacing;

            // Create base positions for the full grid (gridRows x gridCols)
            const total = gridRows * gridCols;
            const basePositions = [];
            for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                    const x = c * spacing - width / 2;
                    const y = r * spacing - height / 2;
                    basePositions.push({ x, y, i: r * gridCols + c });
                }
            }

            // Build an indices array in the requested order, then take the first `count` entries
            let indices = [];
            if (order === 'row') {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            } else if (order === 'column') {
                for (let c = 0; c < gridCols; c++) {
                    for (let r = 0; r < gridRows; r++) {
                        indices.push(r * gridCols + c);
                    }
                }
                indices = indices.slice(0, count);
            } else if (order === 'spiral') {
                indices = getSpiralIndices(gridRows, gridCols).slice(0, count);
            } else if (order === 'random') {
                indices = Array.from({ length: total }, (_, i) => i);
                shuffleArray(indices);
                indices = indices.slice(0, count);
            } else {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            }

            return indices.map(idx => ({ x: basePositions[idx].x, y: basePositions[idx].y, i: idx }));
        }

        // Spiral ordering helper: returns array of indices for a gridSize x gridSize grid
        // Spiral ordering helper for rectangular grid: rows x cols
        function getSpiralIndices(rows, cols) {
            const result = [];
            let top = 0, bottom = rows - 1, left = 0, right = cols - 1;
            while (top <= bottom && left <= right) {
                for (let c = left; c <= right; c++) result.push(top * cols + c);
                top++;
                for (let r = top; r <= bottom; r++) result.push(r * cols + right);
                right--;
                if (top <= bottom) {
                    for (let c = right; c >= left; c--) result.push(bottom * cols + c);
                    bottom--;
                }
                if (left <= right) {
                    for (let r = bottom; r >= top; r--) result.push(r * cols + left);
                    left++;
                }
            }
            return result;
        }

        // Fisher-Yates shuffle
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function createBall(position, index) {
            const geometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const color = colors[index % colors.length];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.3
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y, 0);
            mesh.userData = { number: index + 1 };

            // Create text label as a simple mesh
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Transparent background
            ctx.clearRect(0, 0, 512, 512);
            
            // Draw the number with better antialiasing
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 280px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(index + 1, 256, 256);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            // Create a plane geometry for the text label
            const labelGeometry = new THREE.PlaneGeometry(2.2, 2.2);
            const labelMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
            labelMesh.position.z = ballRadius + 0.1;
            mesh.add(labelMesh);

            gridGroup.add(mesh);
            return mesh;
        }

        // Create or update grid lines and numeric labels for rows/columns
        function updateGridVisuals(count, colsOverride = 0) {
            // Clear previous visuals
            gridLinesGroup.children.slice().forEach(child => {
                gridLinesGroup.remove(child);
                // dispose geometries and materials if any
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
                // dispose textures on children
                if (child.children) {
                    child.children.forEach(c => {
                        if (c.material && c.material.map) c.material.map.dispose();
                        if (c.material) c.material.dispose();
                        if (c.geometry) c.geometry.dispose();
                    });
                }
            });

            const gridCols = colsOverride > 0 ? colsOverride : Math.ceil(Math.sqrt(count));
            const gridRows = Math.ceil(count / gridCols);
            const width = (gridCols - 1) * spacing;
            const height = (gridRows - 1) * spacing;

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xd1d5db });

            const vertices = [];
            // vertical lines
            for (let c = 0; c < gridCols; c++) {
                const x = c * spacing - width / 2;
                vertices.push(x, -height / 2, 0, x, height / 2, 0);
            }
            // horizontal lines
            for (let r = 0; r < gridRows; r++) {
                const y = r * spacing - height / 2;
                vertices.push(-width / 2, y, 0, width / 2, y, 0);
            }

            const lineGeom = new THREE.BufferGeometry();
            lineGeom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const lines = new THREE.LineSegments(lineGeom, lineMaterial);
            gridLinesGroup.add(lines);

            // Labels for columns (top)
            for (let c = 0; c < gridCols; c++) {
                const x = c * spacing - width / 2;
                const label = createTextLabel((c + 1).toString(), 64, '#374151');
                label.position.set(x, height / 2 + spacing * 0.6, 0.1);
                gridLinesGroup.add(label);
            }

            // Labels for rows (left)
            for (let r = 0; r < gridRows; r++) {
                const y = r * spacing - height / 2;
                const label = createTextLabel((r + 1).toString(), 64, '#374151');
                // rotate so text faces the camera similarly; using PlaneGeometry so no rotation needed
                label.position.set(-width / 2 - spacing * 0.6, y, 0.1);
                gridLinesGroup.add(label);
            }
        }

        // helper: create a small 2D canvas text as a THREE.Mesh (Plane) for labels
        function createTextLabel(text, fontSize = 64, color = '#000') {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            ctx.fillStyle = color;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, size / 2, size / 2);

            const tex = new THREE.CanvasTexture(canvas);
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;

            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            const geom = new THREE.PlaneGeometry((fontSize / 64) * 1.2, (fontSize / 64) * 1.2);
            const mesh = new THREE.Mesh(geom, mat);
            return mesh;
        }

        function initializeBalls(count) {
            // Clear existing balls
            balls.forEach(ball => {
                gridGroup.remove(ball);
                disposeBall(ball);
            });
            balls = [];

            // Update grid visuals (lines & labels)
            updateGridVisuals(count, currentCols);

            // Create new balls
            const positions = getGridLayout(count, currentOrder, currentCols);
            positions.forEach((pos, idx) => {
                const ball = createBall(pos, idx);
                balls.push(ball);            // Initial scale animation
            ball.scale.set(0, 0, 0);
            animateBallIn(ball, 0.2 + idx * 0.01);
            });
        }

        function animateBallIn(ball, delay) {
            animatingBalls.add(ball);
            const startTime = performance.now();
            const duration = 500;

            function animate(currentTime) {
                const elapsed = currentTime - startTime - delay * 1000;
                const progress = Math.min(Math.max(elapsed / duration, 0), 1);
                const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                ball.scale.set(easeProgress, easeProgress, easeProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    ball.scale.set(1, 1, 1);
                    animatingBalls.delete(ball);
                }
            }
            requestAnimationFrame(animate);
        }

        function animateBallOut(ball, callback) {
            animatingBalls.add(ball);
            const startTime = performance.now();
            const duration = 400;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                ball.scale.set(1 - progress, 1 - progress, 1 - progress);
                ball.rotation.z += 0.05;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gridGroup.remove(ball);
                    ball.geometry.dispose();
                    ball.material.dispose();
                    if (ball.children[0]) {
                        ball.children[0].material.dispose();
                    }            animatingBalls.delete(ball);
            if (callback) callback();
                }
            }
            requestAnimationFrame(animate);
        }

        function disposeBall(ball) {
            ball.geometry.dispose();
            ball.material.dispose();
            // Dispose children materials
            ball.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            });
        }

        function updateNumbers() {
            const input = document.getElementById('numberInput');
            const newCount = Math.max(1, Math.min(100, parseInt(input.value) || 20));
            input.value = newCount;

            // read order selection
            const order = document.getElementById('orderSelect') ? document.getElementById('orderSelect').value : 'row';
            currentOrder = order;

            // Update grid visuals for the new count/order
            const colsInput = document.getElementById('colsInput');
            const colsVal = colsInput ? parseInt(colsInput.value) || 0 : 0;
            currentCols = colsVal;
            updateGridVisuals(newCount, currentCols);

            const currentCount = balls.length;

            if (newCount > currentCount) {
                // Add new balls
                const positions = getGridLayout(newCount, order, currentCols);
                for (let i = currentCount; i < newCount; i++) {
                    const ball = createBall(positions[i], i);
                    balls.push(ball);
                    animateBallIn(ball, 0.1 + (i - currentCount) * 0.02);
                }
            } else if (newCount < currentCount) {
                // Remove balls with animation
                const ballsToRemove = balls.splice(newCount);
                ballsToRemove.forEach((ball, idx) => {
                    animateBallOut(ball);
                });
            } else {
                // Reposition existing balls
                const newPositions = getGridLayout(newCount, order, currentCols);
                balls.forEach((ball, idx) => {
                    const targetPos = newPositions[idx];
                    animateBallPosition(ball, targetPos);
                });
            }
        }

        function animateBallPosition(ball, targetPos) {
            const startPos = { x: ball.position.x, y: ball.position.y };
            const startTime = performance.now();
            const duration = 500;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                ball.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                ball.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Rotation animation
        function animate() {
            requestAnimationFrame(animate);
            // rotate only if enabled
            if (currentAutoRotate) {
                gridGroup.rotation.z += 0.0005;
            }

            renderer.render(scene, camera);
        }

        // Initialize with default count
        initializeBalls(20);
        animate();

        // Allow Enter key to update
        document.getElementById('numberInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') updateNumbers();
        });

        // Reposition when grouping order or columns change; wire auto-rotate toggle and wheel zoom
        const orderSelect = document.getElementById('orderSelect');
        if (orderSelect) {
            orderSelect.addEventListener('change', () => {
                updateNumbers();
            });
        }

        const colsInput = document.getElementById('colsInput');
        if (colsInput) {
            colsInput.addEventListener('change', () => {
                updateNumbers();
            });
        }

        const autoRotateCheckbox = document.getElementById('autoRotate');
        if (autoRotateCheckbox) {
            autoRotateCheckbox.addEventListener('change', (e) => {
                currentAutoRotate = !!e.target.checked;
            });
        }

        // Mouse wheel zoom (adjust camera z)
        window.addEventListener('wheel', (ev) => {
            // Prevent page scroll when interacting with canvas
            ev.preventDefault();
            const delta = ev.deltaY;
            camera.position.z += delta * 0.02; // adjust sensitivity
            camera.position.z = Math.max(8, Math.min(200, camera.position.z));
            camera.updateProjectionMatrix();
        }, { passive: false });
    </script>
</body>
</html>
