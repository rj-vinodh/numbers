<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kids Numbers Grid Animation</title>
    <style>
        :root {
            --color-primary: #3182ce;
            --color-primary-hover: #2c5aa0;
            --color-success: #22c55e;
            --color-text: #1f2937;
            --color-bg: #f9fafb;
            --color-surface: #ffffff;
            --color-border: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--color-bg);
            overflow: hidden;
        }

        #canvas {
            display: block;
            width: 100%;
            height: calc(100% - 120px);
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--color-surface);
            border-top: 1px solid var(--color-border);
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.08);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: var(--color-text);
            min-width: 120px;
        }

        input[type="number"] {
            padding: 10px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 16px;
            width: 80px;
            color: var(--color-text);
            background: var(--color-surface);
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }

        .btn {
            padding: 10px 20px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: background 150ms ease;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .info {
            margin-left: auto;
            color: #6b7280;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-wrap: wrap;
            }

            label {
                min-width: auto;
            }

            .info {
                margin-left: 0;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label for="numberInput">Count:</label>
            <input type="number" id="numberInput" value="20" min="1" max="100">
        </div>

        <div class="control-group">
            <label for="orderSelect">Group order:</label>
            <select id="orderSelect">
                <option value="row">Row-major (default)</option>
                <option value="column">Column-major</option>
                <option value="spiral">Spiral</option>
                <option value="random">Random</option>
            </select>
        </div>

        <button class="btn" onclick="updateNumbers()">Update Grid</button>
        <div class="info">ðŸ’¡ Change the count and click Update to animate the removal/addition of balls</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf9fafb);

        const canvas = document.getElementById('canvas');
        const camera = new THREE.PerspectiveCamera(
            75,
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        scene.add(directionalLight);

        // Grid container
        const gridGroup = new THREE.Group();
        scene.add(gridGroup);

        // Ball configuration
        const ballRadius = 0.8;
        const spacing = 2.5;
        const colors = [
            0xff6b6b, // Red
            0x4ecdc4, // Teal
            0xffe66d, // Yellow
            0x95e1d3, // Mint
            0xf38181, // Pink
            0xaa96da, // Purple
            0xfcbad3, // Light pink
            0xa8edea, // Cyan
            0xfed766, // Gold
            0xff006e  // Magenta
        ];

        let balls = [];
        let animatingBalls = new Set();
    // Current grouping order (row, column, spiral, random)
    let currentOrder = 'row';

        // Returns an ordered list of positions for `count` items according to `order`
        function getGridLayout(count, order = 'row') {
            const gridSize = Math.ceil(Math.sqrt(count));
            const width = (gridSize - 1) * spacing;
            const height = (gridSize - 1) * spacing;

            // Create base positions for the full grid (gridSize * gridSize)
            const total = gridSize * gridSize;
            const basePositions = [];
            for (let i = 0; i < total; i++) {
                const row = Math.floor(i / gridSize);
                const col = i % gridSize;
                const x = col * spacing - width / 2;
                const y = row * spacing - height / 2;
                basePositions.push({ x, y, i });
            }

            // Build an indices array in the requested order, then take the first `count` entries
            let indices = [];
            if (order === 'row') {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            } else if (order === 'column') {
                for (let c = 0; c < gridSize; c++) {
                    for (let r = 0; r < gridSize; r++) {
                        indices.push(r * gridSize + c);
                    }
                }
                indices = indices.slice(0, count);
            } else if (order === 'spiral') {
                indices = getSpiralIndices(gridSize).slice(0, count);
            } else if (order === 'random') {
                indices = Array.from({ length: total }, (_, i) => i);
                shuffleArray(indices);
                indices = indices.slice(0, count);
            } else {
                indices = Array.from({ length: total }, (_, i) => i).slice(0, count);
            }

            return indices.map(i => ({ x: basePositions[i].x, y: basePositions[i].y, i }));
        }

        // Spiral ordering helper: returns array of indices for a gridSize x gridSize grid
        function getSpiralIndices(gridSize) {
            const result = [];
            let top = 0, bottom = gridSize - 1, left = 0, right = gridSize - 1;
            while (top <= bottom && left <= right) {
                for (let c = left; c <= right; c++) result.push(top * gridSize + c);
                top++;
                for (let r = top; r <= bottom; r++) result.push(r * gridSize + right);
                right--;
                if (top <= bottom) {
                    for (let c = right; c >= left; c--) result.push(bottom * gridSize + c);
                    bottom--;
                }
                if (left <= right) {
                    for (let r = bottom; r >= top; r--) result.push(r * gridSize + left);
                    left++;
                }
            }
            return result;
        }

        // Fisher-Yates shuffle
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function createBall(position, index) {
            const geometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const color = colors[index % colors.length];
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.3
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(position.x, position.y, 0);
            mesh.userData = { number: index + 1 };

            // Create text label as a simple mesh
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Transparent background
            ctx.clearRect(0, 0, 512, 512);
            
            // Draw the number with better antialiasing
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 280px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(index + 1, 256, 256);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            // Create a plane geometry for the text label
            const labelGeometry = new THREE.PlaneGeometry(2.2, 2.2);
            const labelMaterial = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
            labelMesh.position.z = ballRadius + 0.1;
            mesh.add(labelMesh);

            gridGroup.add(mesh);
            return mesh;
        }

        function initializeBalls(count) {
            // Clear existing balls
            balls.forEach(ball => {
                gridGroup.remove(ball);
                disposeBall(ball);
            });
            balls = [];

            // Create new balls
            const positions = getGridLayout(count, currentOrder);
            positions.forEach((pos, idx) => {
                const ball = createBall(pos, idx);
                balls.push(ball);            // Initial scale animation
            ball.scale.set(0, 0, 0);
            animateBallIn(ball, 0.2 + idx * 0.01);
            });
        }

        function animateBallIn(ball, delay) {
            animatingBalls.add(ball);
            const startTime = performance.now();
            const duration = 500;

            function animate(currentTime) {
                const elapsed = currentTime - startTime - delay * 1000;
                const progress = Math.min(Math.max(elapsed / duration, 0), 1);
                const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                ball.scale.set(easeProgress, easeProgress, easeProgress);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    ball.scale.set(1, 1, 1);
                    animatingBalls.delete(ball);
                }
            }
            requestAnimationFrame(animate);
        }

        function animateBallOut(ball, callback) {
            animatingBalls.add(ball);
            const startTime = performance.now();
            const duration = 400;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                ball.scale.set(1 - progress, 1 - progress, 1 - progress);
                ball.rotation.z += 0.05;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    gridGroup.remove(ball);
                    ball.geometry.dispose();
                    ball.material.dispose();
                    if (ball.children[0]) {
                        ball.children[0].material.dispose();
                    }            animatingBalls.delete(ball);
            if (callback) callback();
                }
            }
            requestAnimationFrame(animate);
        }

        function disposeBall(ball) {
            ball.geometry.dispose();
            ball.material.dispose();
            // Dispose children materials
            ball.children.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
            });
        }

        function updateNumbers() {
            const input = document.getElementById('numberInput');
            const newCount = Math.max(1, Math.min(100, parseInt(input.value) || 20));
            input.value = newCount;

            // read order selection
            const order = document.getElementById('orderSelect') ? document.getElementById('orderSelect').value : 'row';
            currentOrder = order;

            const currentCount = balls.length;

            if (newCount > currentCount) {
                // Add new balls
                const positions = getGridLayout(newCount, order);
                for (let i = currentCount; i < newCount; i++) {
                    const ball = createBall(positions[i], i);
                    balls.push(ball);
                    animateBallIn(ball, 0.1 + (i - currentCount) * 0.02);
                }
            } else if (newCount < currentCount) {
                // Remove balls with animation
                const ballsToRemove = balls.splice(newCount);
                ballsToRemove.forEach((ball, idx) => {
                    animateBallOut(ball);
                });
            } else {
                // Reposition existing balls
                const newPositions = getGridLayout(newCount, order);
                balls.forEach((ball, idx) => {
                    const targetPos = newPositions[idx];
                    animateBallPosition(ball, targetPos);
                });
            }
        }

        function animateBallPosition(ball, targetPos) {
            const startPos = { x: ball.position.x, y: ball.position.y };
            const startTime = performance.now();
            const duration = 500;

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

                ball.position.x = startPos.x + (targetPos.x - startPos.x) * easeProgress;
                ball.position.y = startPos.y + (targetPos.y - startPos.y) * easeProgress;

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }
            requestAnimationFrame(animate);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Rotation animation
        function animate() {
            requestAnimationFrame(animate);
            
            gridGroup.rotation.z += 0.0005;

            renderer.render(scene, camera);
        }

        // Initialize with default count
        initializeBalls(20);
        animate();

        // Allow Enter key to update
        document.getElementById('numberInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') updateNumbers();
        });

        // Reposition when grouping order changes
        const orderSelect = document.getElementById('orderSelect');
        if (orderSelect) {
            orderSelect.addEventListener('change', () => {
                // Recalculate positions for current count using new order
                updateNumbers();
            });
        }
    </script>
</body>
</html>
